<!doctype html>
<html>
        <head>
                <meta charset="utf-8">
                <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

                <title>RustFest 2019 Barcelona: WebRTC, Tokio &amp; GStreamer Workshop</title>

                <link rel="stylesheet" href="css/reset.css">
                <link rel="stylesheet" href="css/reveal.css">
                <link rel="stylesheet" href="css/theme/night.css">
                <link rel="stylesheet" href="css/reveal-override.css"/>

                <!-- Theme used for syntax highlighting of code -->
                <link rel="stylesheet" href="lib/css/monokai.css">

                <!-- Printing and PDF exports -->
                <script>
                        var link = document.createElement( 'link' );
                        link.rel = 'stylesheet';
                        link.type = 'text/css';
                        link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
                        document.getElementsByTagName( 'head' )[0].appendChild( link );
                </script>
        </head>
        <body>
                <div class="reveal">
                        <div class="slides">
<section data-markdown>
    <textarea data-template>
      ### Workshop: WebRTC, Tokio &amp; GStreamer

      <br>
      RustFest 2019 Barcelona

      9-10 November 2019

      <br>
      Sebastian 'slomo' Dröge
      <br>
      <img data-src="logos/rust.svg" style="border:0px;
      background-color:rgba(0,0,0,0.0); width: 150px; height: auto">
    </textarea>
</section>

<section data-markdown>
  <textarea data-template>
    #### Who: Sebastian Dröge

    - GStreamer developer and maintainer since 2006
    - Rust enthusiast
    - Maintainer of the GStreamer Rust bindings
    - Co-founder of Centricular Ltd
  </textarea>
</section>

<section data-markdown>
  <textarea data-template>
    ### Overview
  </textarea>
</section>

<section data-markdown>
  <textarea data-template>
    #### We're going to develop a cross-platform, native WebRTC application

    - Written in safe Rust
    - Audio/video real-time communication
      - like Skype, Hangouts, zoom. ...
      - today: 1-on-1, tomorrow: many-to-many
    - Command-line
    - Can communicate with browsers or itself
    - Webcam/mic or generated test video/audio
  </textarea>
</section>

<section data-markdown>
  <textarea data-template>
    Let's see it in action
  </textarea>
</section>

<section data-markdown>
  <textarea data-template>
    #### WebRTC
  </textarea>
</section>

<section data-markdown>
  <textarea data-template>
    #### WebRTC

    - W3C standard for real-time communication on the web

    - Defines underlying protocols
      - RTP, DTLS/SRTP, SCTP, ICE, SDP
      - Opus audio, VP8/H264 video

    <aside class="notes" data-markdown>
      - Supported by all major browsers
    </aside>
  </textarea>
</section>

<section data-markdown>
  <textarea data-template>
    #### WebRTC

    - Defines negotiation/handshake between peers
      - But not the transport!

    - Defines a JavaScript API
  </textarea>
</section>

<section data-markdown>
  <textarea data-template>
    #### WebRTC

    - Only few implementations available
      - Google's WebRTC used by almost all browsers
      - GStreamer's used by Servo and us
       - Not feature-equivalent!
      - Janus, ...
  </textarea>
</section>

<section data-markdown>
  <textarea data-template>
    #### WebRTC - Signalling

    - Media transport is peer to peer
      - Peers need to find each other

    - Usually: WebSocket connection via a server
      - Allows both peers to know about each other
      - We'll do this!
  </textarea>
</section>

<section data-markdown>
  <textarea data-template>
    #### WebRTC - Media Description Signalling

    <img data-src="img/jsep.png" style="border:0px; background-color:rgba(0,0,0,0.0);">

    <aside class="notes" data-markdown>
      - For finding common features (codecs, etc)
      - Offer/answer model
      - One initiates with an offer, all it can do
      - Other answers based on that with the common subset
    </aside>
  </textarea>
</section>

<section data-markdown>
  <textarea data-template>
    #### WebRTC - ICE Signalling, or: The Internet sucks

    <img data-src="img/turn.png" style="border:0px;
    background-color:rgba(255,255,255,255);">

    <aside class="notes" data-markdown>
        - No direct connections possible, usually (NATs)
        - ICE tries to find ways
        - Direct, STUN (hole punching), TURN (proxy)
    </aside>
  </textarea>
</section>

<section data-markdown>
  <textarea data-template>
    #### WebRTC - More infos

    - https://www.w3.org/TR/webrtc/
    - https://www.html5rocks.com/en/tutorials/webrtc/infrastructure
      - Pictures before stolen from there
    - https://webrtchacks.com/sdp-anatomy/
  </textarea>
</section>

<section data-markdown>
  <textarea data-template>
    #### Tokio
  </textarea>
</section>

<section data-markdown>
  <textarea data-template>
    #### Tokio

    - One of the two major Rust async IO frameworks
      - A few years old by now
      - The other &amp; newer is async-std: https://async.rs

    - We use Tokio here
      - No WebSocket library for async-std yet
  </textarea>
</section>

<section data-markdown>
  <textarea data-template>
    #### Tokio

    - Making use of the Rust async infrastructure
      - `std::future::Future`, `Stream`, etc.
      - `async` / `await`
      - Needs an alpha release currently

    - Provides a runtime/executor on top of it
      - Scheduling futures
      - Concrete IO types, e.g. `TcpStream`
      - Timers, etc.

    <aside class="notes" data-markdown>
      - Basically the same as async-std but not the same
        API: async-std follows std patterns more closely
      - Tokio gives more control (currently)
      - See Florian's talk tomorrow
    </aside>
  </textarea>
</section>

<section data-markdown>
  <textarea data-template>
    #### Tokio - Why async IO?

    - "Userspace Threads"
      - OS threads are expensive
    - Handle multiple connections and other tasks in fewer OS threads
    - Scalability to 10k or more connections

    <aside class="notes" data-markdown>
      - Can do other things on the thread while waiting for IO
    </aside>
  </textarea>
</section>

<section data-markdown>
  <textarea data-template>
    #### Tokio - `std::future::Future`

    - A value that represents the result of an operation
      - The result might not be available yet!
    - Get notified when the result is available
    - Combinators and `async` / `await` for working with them

    - Spawned on an executor to actually be started

    <aside class="notes" data-markdown>
      - Also other executors: GLib, threadpools, etc
    </aside>
  </textarea>
</section>

<section>
  <h4>Tokio - Futures</h4>
  <pre><code class="rust">
// Do an HTTP request and print the body
let fut = reqwest::get("https://...")
    .and_then(|resp| {
        println!("body: {:?}", resp.text());
    })
    .or_else(|err| ...);

// Spawn and block on the future
let rt = tokio::Runtime::new().unwrap();
rt.block_on(fut);
  </code></pre>
  <aside class="notes" data-markdown>
    - Can spawn many things on the runtime
    - No need to block in general
    - Blocking gives the result of the future
  </aside>
</section>

<section>
  <h4>Tokio - Async/await</h4>
  <pre><code class="rust">
// Do an HTTP request and print the body
let fut = async {
    let resp = reqwest::get("https://...")
        .await?;
    println!("body: {:?}", resp.text());
};

// Spawn and block on the future
let rt = tokio::Runtime::new().unwrap();
rt.block_on(fut);
  </code></pre>
  <aside class="notes" data-markdown>
    - More imperative control flow
    - Much easier with borrowing, etc.
    - Works closer to normal Rust code
  </aside>
</section>

<section data-markdown>
  <textarea data-template>
    #### Tokio - `Stream`s, `Sink`s, etc.

    - `Stream`: Async version of `Iterator`
    - `Sink`: For async writing out one or more value
    - `AsyncRead` / `AsyncWrite`: See `Read` / `Write`
  </textarea>
</section>

<section data-markdown>
  <textarea data-template>
    #### GStreamer
  </textarea>
</section>

<section data-markdown>
  <textarea data-template>
    #### GStreamer

    - Cross-platform multimedia framework
    - Pipeline-based, heavily multi-threaded
    - Written in C with GObject
      - Great Rust bindings exist
      - Not tied to GTK+ or GNOME at all

    <aside class="notes" data-markdown>
      - Good Windows/macOS/iOS/Android/Linux/BSD support
      - Used "everywhere"
      - Binaries, free software
    </aside>
  </textarea>
</section>

<section data-markdown>
  <textarea data-template>
    <img data-src="img/pipeline_generic.svg" style="border:0px; background-color:rgba(0,0,0,0.0);">

    <aside class="notes" data-markdown>
      - Bins, elements: hierarchy, reusable
      - Message-passing communication between elements
      - Topology can be changed at runtime
    </aside>
  </textarea>
</section>

<section data-markdown>
  <textarea data-template>
    #### GStreamer

    - Toolbox for higher-level multimedia processing
    - Batteries included
    - Usable from many languages

    <aside class="notes" data-markdown>
      - Components for all kinds of tasks
      - Working on a pipeline graph instead of
        shovling data around manually
      - Not alternative to ffmpeg: making use of it and other libraries
    </aside>
  </textarea>
</section>

<section data-markdown>
  <textarea data-template>
    #### GStreamer is not

    - Media player or playback library
    - Codec and protocol library
    - Transcoding tool
    - Streaming server
    <br>
    ... can be used to build all that!
  </textarea>
</section>

<section data-markdown>
  <textarea data-template>
    #### Object-oriented Programming
  </textarea>
</section>

<section data-markdown>
  <textarea data-template>
    #### OOP

    - GStreamer is an OOP API
    - Rust has no support for subclassing/inheritance
      - Emulated transparently in the bindings via traits
      - Creating new subclasses is possible but we don't do that
  </textarea>
</section>

<section data-markdown>
  <textarea data-template>
    #### OOP

    - Each object behaves like a `Rc&lt;RefCell&lt;T&gt;&gt;`
      - Refcounting + interior mutability
    - Type system with RTTI, introspection, (partial) reflection
    - Bindings expose this in safe Rust

    <aside class="notes" data-markdown>
      - Get type id, check class hierarchy, properties, signals
      - Create types from id, property/signal via string names
      - GValue container for arbitrary types
      - up/down casting
    </aside>
  </textarea>
</section>

<section data-markdown>
  <textarea data-template>
    ### Let's get started!
  </textarea>
</section>

<section data-markdown>
  <textarea data-template>
    #### Requirements

    - Rust toolchain 1.39 or recent nightly/beta
      - MSVC toolchain on Windows
    - GStreamer 1.14 or newer
      - Binaries from USB for Windows/macOS
      - Your distro's packages for Linux
       - Make sure to install the WebRTC support
    - Laptop with webcam and Internet connection
      - No webcam is also fine

    <aside class="notes" data-markdown>
      - Binaries contain everything we need for the
        workshop, otherwise compiling via homebrew
        or similar would take ages
      - Work together with your neighbour if you want
    </aside>
  </textarea>
</section>

<section data-markdown>
  <textarea data-template>
    #### Setup

    - Set `PKG_CONFIG_PATH` environment variable to the `lib/pkgconfig` directory
    - Include the `bin` directory in your `PATH`
    - Set `GST_PLUGIN_SYSTEM_PATH` to `lib/gstreamer-1.0`
    - Set `XDG_DATA_DIRS` to include `share`

    <aside class="notes" data-markdown>
      - Anything else?
    </aside>
  </textarea>
</section>

<section data-markdown>
  <textarea data-template>
    #### Code

    - Final application at
      - https://github.com/sdroege/rustfest-barcelona19-gst-webrtc-workshop
    - Tags for the separate steps of the workshop

    <aside class="notes" data-markdown>
      - Implementation in incremental steps here
    </aside>
  </textarea>
</section>

<section data-markdown>
  <textarea data-template>
    #### Docs

    - Docs for GLib and GStreamer Rust bindings at
      - https://gtk-rs.org/docs/glib
      - https://slomo.pages.freedesktop.org/rustdocs/gstreamer/gstreamer/
  </textarea>
</section>

<section data-markdown>
  <textarea data-template>
    ### Chapter 1
    #### Tokio skeleton
  </textarea>
</section>

<section data-markdown>
  <textarea data-template>
    #### Basics

    - We'll go through each important concept first
      - What is it, how can it be used?
    - Then go together through the code with more explanations
    - Finally everybody has some time to replicate the chapter
      - Based on existing code
      - Reading docs
      - Playing around
  </textarea>
</section>

<section data-markdown>
  <textarea data-template>
    #### Project Setup

    - `cargo init`
    - Add `futures-preview` 0.3.0-alpha.19 to `Cargo.toml`
      - Add `features = ["async-await"]`
    - Add `tokio` 0.2.0-alpha.6 to `Cargo.toml`
    - `use tokio::prelude::*`
      - Brings all the important traits into scope
  </textarea>
</section>

<section data-markdown>
  <textarea data-template>
    #### `#[tokio::main]`

    - Hides the runtime setup from us
    - Allows `main()` to be an `async fn`
  </textarea>
</section>

<section data-markdown>
  <textarea data-template>
    #### Look over the code
    <aside class="notes" data-markdown>
      - Does nothing, inefficient
    </aside>
  </textarea>
</section>

<section data-markdown>
  <textarea data-template>
    ### Chapter 2
    #### Command-line arguments
  </textarea>
</section>

<section data-markdown>
  <textarea data-template>
    #### `structopt`

    - Derives a command-line argument parser from on a struct
      - `#[derive(StructOpt)]`
    - Gives an instance of that struct, or error
    - Generates `--help` output

    - We add a `--server` argument with a default value
  </textarea>
</section>

<section data-markdown>
  <textarea data-template>
    #### Look over the code
  </textarea>
</section>

<section data-markdown>
  <textarea data-template>
    ### Chapter 3
    #### WebSocket Connection
  </textarea>
</section>

<section data-markdown>
  <textarea data-template>
    #### WebSocket

    - Packet-based transport protocol
    - On top of an (upgraded) HTTP connection
    - Allows sending arbitrary data, bidirectional
      - We use it for signalling here
      - We use an existing signalling server
      - `wss://webrtc.nirbheek.in:8443`
  </textarea>
</section>

<section data-markdown>
  <textarea data-template>
    #### Tungstenite

    - WebSocket implementation in Rust
    - `tungstenite-tokio` for tokio integration
    - `connect_async(url)` convenience function
  </textarea>
</section>

<section data-markdown>
  <textarea data-template>
    #### Tungstenite

    - Provides a `Stream` and `Sink` for `Message`s
      - `Message::Text("123")`, `Message:Ping(_)`
      - `sink.write(msg)`
      - `let msg = stream.next().await`

    - Add dependencies for `url`, `tungestenite`, `tokio-tungstenite`
      - See `Cargo.toml` for details
  </textarea>
</section>

<section data-markdown>
  <textarea data-template>
    #### Error handling

    - We make use of the `anyhow` crate here
    - Provides `anyhow::Error`
      - basically `Box&lt;Error&gt;` on steroids
    - `anyhow!`, `bail`, etc. macros
  </textarea>
</section>

<section data-markdown>
  <textarea data-template>
    #### Signalling

    - The server wants each new client to introduce themselves
      - `HELLO [random id]`

    - It will reply with `HELLO`
  </textarea>
</section>

<section data-markdown>
  <textarea data-template>
    #### Look over the code
  </textarea>
</section>

<section data-markdown>
  <textarea data-template>
    ### Chapter 4
    #### Joining a session and message loop
  </textarea>
</section>

<section data-markdown>
  <textarea data-template>
    #### Joining a session

    - The server wants us to join with `SESSION [id]`
    - Answers with `SESSION_OK` or `ERROR [...]`
    - Add a command-line argument for the session id
      - See https://webrtc.nirbheek.in/ for getting one
  </textarea>
</section>

<section data-markdown>
  <textarea data-template>
    #### Message Loop

    - Afterwards we need to handle messages asynchronously
      - Ping/pong from WebSocket
      - Connection closed
      - SDP offer/answer, ICE, ...
    - Also later from non-WebSocket sources

    - `futures::select!` loop
  </textarea>
</section>

<section>
  <h4>futures::select!</h4>
  <pre><code class="rust">
loop {
    select! {
      msg = stream.select_next_some() {
          match msg? {
              ...
          }
      },
      complete =&gt; break,
    };
}
  </code></pre>
</section>

<section data-markdown>
  <textarea data-template>
    #### Look over the code
  </textarea>
</section>

<section data-markdown>
  <textarea data-template>
    ### Chapter 5
    #### Application State
  </textarea>
</section>

<section data-markdown>
  <textarea data-template>
    #### `Arc` and weak references

    - We're going to introduce new threads
    - Also GStreamer has a callback-based API

    - We'll need to share application state in multiple places

    <aside class="notes" data-markdown>
      - Wouldn't need that if we handled all in the same task
    </aside>
  </textarea>
</section>

<section data-markdown>
  <textarea data-template>
    #### `Arc` and weak references

    - `Arc` gives atomic reference counting
      - Struct is destroyed when no more references left
    - `Weak` gives a weak reference
      - Does not keep struct alive
      - `get()` might return `None`
      - For breaking reference cycles

    <aside class="notes" data-markdown>
      - Reference cycle explanation
    </aside>
  </textarea>
</section>

<section data-markdown>
  <textarea data-template>
    #### `Arc` and weak references

    - `AppInner` struct with actual state
    - Add tuple structs around `Arc` and `Weak`
    - Add `upgrade()` / `downgrade()` functions
    - `upgrade_weak!()` macro

    <aside class="notes" data-markdown>
      - Boilerplate I use in many places
      - Macro explanation
    </aside>
  </textarea>
</section>

<section data-markdown>
  <textarea data-template>
    #### Look over the code

    <aside class="notes" data-markdown>
      - we also move text message handling into the state
      - and store our arguments for later use
      - we won't make use of it much yet!
    </aside>
  </textarea>
</section>

<section data-markdown>
  <textarea data-template>
    ### Chapter 6
    #### GStreamer Introduction
  </textarea>
</section>

<section data-markdown>
  <textarea data-template>
    #### `gst::init()`

    - Necessary to initialize GStreamer
    - Checks what plugins are available and changed since last run

    <aside class="notes" data-markdown>
      - Not calling it will make most GStreamer API panic
    </aside>
  </textarea>
</section>

<section data-markdown>
  <textarea data-template>
    #### `gst::Pipeline`

    - Top-level pipeline object
    - Contains the actual pipeline elements
    - Provides clock and messaging infrastructure

    <aside class="notes" data-markdown>
      - gst::Bin, gst::Element
      - Have states like all elements
      - Can contain/manage other elements
    </aside>
  </textarea>
</section>

<section data-markdown>
  <textarea data-template>
    #### `gst::parse_launch()`

    - Creates a `gst::Pipeline` from a textual description
    - `videotestsrc pattern=ball ! videoconvert ! autovideosink`
      - Also allows branching, parallel chains, ...
      - Can also use `autovideosrc` and `autoaudiosrc`

    - Returns a `gst::Element`: use `downcast()`!

    <aside class="notes" data-markdown>
      - Also possible to create and connect each part manually
      - Gives more power
      - Explain elements
    </aside>
  </textarea>
</section>

<section data-markdown>
  <textarea data-template>
    #### Element States

    - Pipelines/elements have states
    - We need to set them to the `Playing` state so they start
    - Might block
      - Do it asynchronously!
      - `element.call_async(|element| ...)`
  </textarea>
</section>

<section data-markdown>
  <textarea data-template>
    #### Look over the code
  </textarea>
</section>

<section data-markdown>
  <textarea data-template>
    ### Chapter 7
    #### GStreamer Message Handling
  </textarea>
</section>

<section data-markdown>
  <textarea data-template>
    #### `gst::Bus`

    - Provides message notifications from the pipeline
      - Errors, Warnings, End-of-stream, ...
    - `gst::MessageView` enum for inspecting messages
    - Can give us messages from a callback
      - Pass to our message loop via mpsc channels

    <aside class="notes" data-markdown>
      - GStreamer multi-threaded
      - Basically a thread-safe message queue
    </aside>
  </textarea>
</section>

<section data-markdown>
  <textarea data-template>
    #### Element states

    - Setting the pipeline state can fail
    - Asynchronously send an error message on the bus
      - `gst_element_error!` macro on the pipeline

    <aside class="notes" data-markdown>
    </aside>
  </textarea>
</section>

<section data-markdown>
  <textarea data-template>
    #### Look over the code

    <aside class="notes" data-markdown>
    </aside>
  </textarea>
</section>

<section data-markdown>
  <textarea data-template>
    ### Chapter 8
    #### WebRTC Offer Part 1
  </textarea>
</section>

<section data-markdown>
  <textarea data-template>
    <img data-src="img/pipeline_webrtc.svg" style="border:0px; background-color:rgba(0,0,0,0.0);">
  </textarea>
</section>

<section data-markdown>
  <textarea data-template>
    #### `webrtcbin`

    - Represents a single WebRTC session
      - Audio, video, datachannel, etc.
    - Does SDP/ICE and network handling
    - Input/output: RTP packets
      - Our input stream, their stream

    <aside class="notes" data-markdown>
      - We only have to provide correct input
      - Pass SDP/ICE around via WebSocket
      - Handle incoming streams
    </aside>
  </textarea>
</section>

<section data-markdown>
  <textarea data-template>
    #### Encoding and RTP payloading

    - We'll use VP8 / Opus
    - `vp8enc`: encodes raw video
      - Need to set "deadline" property to 1
    - `opusenc`: encodes raw audio
    - `rtpvp8pay` / `rtpopuspay`: packetizes RTP

    <aside class="notes" data-markdown>
      - Deadline: produce live, ASAP
    </aside>
  </textarea>
</section>

<section data-markdown>
  <textarea data-template>
    #### `on-negotiation-needed` signal

    - Emitted once `webrtcbin` needs (re-)negotiation
    - We'll get an Offer SDP from here later
  </textarea>
</section>

<section data-markdown>
  <textarea data-template>
    #### Look over the code

    <aside class="notes" data-markdown>
      - Also set "is-live" to true
    </aside>
  </textarea>
</section>

<section data-markdown>
  <textarea data-template>
    ### Chapter 9
    #### WebRTC Offer Part 2
  </textarea>
</section>

<section data-markdown>
  <textarea data-template>
    #### `on-negotiation-needed` signal

    - Here we need to call the "create-offer" action on `webrtcbin`
    - It takes an `gst::Promise`
      - Like a `Future`, gets the result later
      - `change_function` callback when value is available
  </textarea>
</section>

<section data-markdown>
  <textarea data-template>
    #### SDP

    - `create-offer` promise gives us an SDP for our streams
    - Set on `webrtcbin` via `set-local-description`
    - We need to send that to the peer so it can send us its own
    - API in the `gstreamer-sdp` library
      - We simply convert it to a string
  </textarea>
</section>

<section data-markdown>
  <textarea data-template>
    #### Serde

    - Library for (de-)serializing in various formats
    - We send the SDP as JSON to the peer
      - `serde-json` crate
    - `#[derive(Serialize, Deserialize)]`
  </textarea>
</section>

<section data-markdown>
  <textarea data-template>
    #### Look over the code
  </textarea>
</section>

<section data-markdown>
  <textarea data-template>
    ### Chapter 10
    #### WebRTC Offer Part 3
  </textarea>
</section>

<section data-markdown>
  <textarea data-template>
    #### Channels

    - We got the WebRTC Offer in some arbitrary thread now
    - It has to be send via WebSocket to the peer but we have no
      access to the WebSocket here
    - Solution: Use another mpsc channel for outgoing WebSocket messages
  </textarea>
</section>

<section data-markdown>
  <textarea data-template>
    #### Look over the code
  </textarea>
</section>

<section data-markdown>
  <textarea data-template>
    ### Chapter 11
    #### WebRTC Answer and ICE
  </textarea>
</section>

<section data-markdown>
  <textarea data-template>
    #### Handle WebSocket messages

    - Peer is going to send us its SDP
      - `set-remote-description` on the `webrtcbin`
    - Peer is going to send us ICE candidates
      - `add-ice-candidate` on the `webrtcbin`
    - We have to send ICE candidates
      - `on-ice-candidate` signal
  </textarea>
</section>

<section data-markdown>
  <textarea data-template>
    #### Look over the code
  </textarea>
</section>

<section data-markdown>
  <textarea data-template>
    ### Chapter 12
    #### WebRTC Incoming Streams
  </textarea>
</section>

<section data-markdown>
  <textarea data-template>
    #### `gst::Pad`

    - "Connector" or "port" between elements
      - Source direction outputs data
      - Sink direction consumes data
    - Can be static, appear at any time or on request
      - `elt.get_static_pad()`
      - "pad-added" / "pad-removed" signals
      - `elt.request_pad()` / `elt.release_request_pad()`

    <aside class="notes" data-markdown>
      - Examples for pad types
    </aside>
  </textarea>
</section>

<section data-markdown>
  <textarea data-template>
    #### `gst::Caps`

    - Format description
      - e.g. `image/jpeg, width=640, height=480`
    - Pads give their format via `Caps`

    <aside class="notes" data-markdown>
      - Like mimetypes
      - Fields optional, can describe multiple possibilities
      - Ranges, lists, ...
    </aside>
  </textarea>
</section>

<section data-markdown>
  <textarea data-template>
    #### `decodebin`

    - Automatically decodes one input stream
      - Collects decoders, etc. as needed
    - "pad-added" for each decoded stream

    <aside class="notes" data-markdown>
    </aside>
  </textarea>
</section>

<section data-markdown>
  <textarea data-template>
    #### `gst::parse_bin_from_description()`

    - Similar to `gst::parse_launch()` but creates a `gst::Bin`
      - a "pipeline part" containing one or more elements

    <aside class="notes" data-markdown>
      - We need to connect the result into our main pipeline
    </aside>
  </textarea>
</section>

<section data-markdown>
  <textarea data-template>
    #### Incoming streams

    - "pad-added" signal on `webrtcbin` for the encoded streams
    - Link in a `decodebin` element
    - "pad-added" signal on `decodebin` for the decoded streams
    - Link to an audio or video sink
      - "queue ! audioconvert ! audioresample ! autoaudiosink"
      - "queue ! videoconvert ! videoscale ! autovideosink"

      <aside class="notes" data-markdown>
        - queues for buffering
        - sync state with parent
      </aside>
  </textarea>
</section>

<section data-markdown>
  <textarea data-template>
    #### Look over the code
  </textarea>
</section>

<section data-markdown>
  <textarea data-template>
    ### Chapter 13
    #### WebRTC Accepting an Offer
  </textarea>
</section>

<section data-markdown>
  <textarea data-template>
    #### Accepting an Offer

    - Right now we can only initiate sessions
    - We optionally want to be able to answer offers
  </textarea>
</section>

<section data-markdown>
  <textarea data-template>
    #### Accepting an Offer

    - Don't handle "on-negotiation-needed"
    - Wait for an Offer SDP
    - "set-remote-description", and "create-answer"
    - Send to the peer
  </textarea>
</section>

<section data-markdown>
  <textarea data-template>
    #### Look over the code
  </textarea>
</section>

<section data-markdown>
  <textarea data-template>
    ## Thanks!

    We hope you enjoyed the workshop and could learn some useful new tools
  </textarea>
</section>

                        </div>
                </div>

                <script src="js/reveal.js"></script>

                <script>
                        // More info about config & dependencies:
                        // - https://github.com/hakimel/reveal.js#configuration
                        // - https://github.com/hakimel/reveal.js#dependencies
                        Reveal.initialize({
                                dependencies: [
                                        { src: 'plugin/markdown/marked.js' },
                                        { src: 'plugin/markdown/markdown.js' },
                                        { src: 'plugin/notes/notes.js', async: true },
                                        { src: 'plugin/highlight/highlight.js', async: true }
                                ]
                        });
                </script>
        </body>
</html>
